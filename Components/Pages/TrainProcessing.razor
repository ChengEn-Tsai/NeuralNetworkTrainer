@page "/train/Processing"
@using MudBlazor
@inject HttpClient Http

<div>
    <MudText Typo="Typo.h4" Align="Align.Center">Training Progress</MudText>

    <MudText Typo="Typo.h5">Epoch: @metrics.Epoch</MudText>
    <MudText>Loss: @metrics.Loss</MudText>
    <MudText>Accuracy: @metrics.Accuracy</MudText>
    <MudText>Validation Loss: @metrics.ValLoss</MudText>
    <MudText>Validation Accuracy: @metrics.ValAccuracy</MudText>
</div>

<!-- Render the combined chart -->
<div>
    <MudChart ChartType="ChartType.Line" ChartSeries="@Series" XAxisLabels="@epochLabels.ToArray()" Width="100%" Height="350px" />
</div>

<div>
    <MudText Typo="Typo.h5">Standard Output (Training Details):</MudText>
    <MudPaper Class="p-4" Elevation="1">
        <MudText>@output</MudText>
    </MudPaper>
</div>

@code {
    private TrainingMetrics metrics = new TrainingMetrics();
    private List<ChartSeries> Series = new List<ChartSeries>();
    private List<string> epochLabels = new List<string>();
    private string output = "";

    protected override void OnInitialized()
    {
        // Initialize the chart series with empty data arrays
        Series.Add(new ChartSeries { Name = "Loss", Data = Array.Empty<double>() });
        Series.Add(new ChartSeries { Name = "Accuracy", Data = Array.Empty<double>() });
        Series.Add(new ChartSeries { Name = "Validation Loss", Data = Array.Empty<double>() });
        Series.Add(new ChartSeries { Name = "Validation Accuracy", Data = Array.Empty<double>() });

        // Start polling for metrics
        _ = PollTrainingStatus();
    }

    private async Task PollTrainingStatus()
    {
        bool isTrainingComplete = false;

        while (!isTrainingComplete)
        {
            try
            {
                var latestMetrics = await Http.GetFromJsonAsync<TrainingMetrics>("api/NeuralNetwork/status");

                if (latestMetrics != null)
                {
                    await InvokeAsync(() =>
                    {
                        metrics = latestMetrics;

                        // Update the epoch labels
                        epochLabels.Add($"Epoch {metrics.Epoch}");

                        // Update the data for each series
                        UpdateSeriesData(Series[0], metrics.Loss.Value);
                        UpdateSeriesData(Series[1], metrics.Accuracy.Value);
                        UpdateSeriesData(Series[2], metrics.ValLoss.Value);
                        UpdateSeriesData(Series[3], metrics.ValAccuracy.Value);

                        // Optionally limit data points
                        const int maxDataPoints = 100;
                        if (epochLabels.Count > maxDataPoints)
                        {
                            epochLabels.RemoveAt(0);
                            TrimSeriesData(Series[0]);
                            TrimSeriesData(Series[1]);
                            TrimSeriesData(Series[2]);
                            TrimSeriesData(Series[3]);
                        }

                        // Append to the standard output
                        output += $"Epoch {metrics.Epoch}: Loss = {metrics.Loss:F4}, Accuracy = {metrics.Accuracy:P2}, " +
                                  $"Val Loss = {metrics.ValLoss:F4}, Val Accuracy = {metrics.ValAccuracy:P2}\n";

                        StateHasChanged();
                    });

                    // Check if training is complete
                    if (latestMetrics.IsTrainingComplete)
                    {
                        isTrainingComplete = true;
                    }
                }
            }
            catch (Exception ex)
            {
                await InvokeAsync(() =>
                {
                    output += $"Error fetching metrics: {ex.Message}\n";
                    StateHasChanged();
                });
            }

            // Wait before polling again
            await Task.Delay(2000);
        }

        // Optionally, you can display a message indicating that training is complete
        await InvokeAsync(() =>
        {
            output += "\nTraining has completed.";
            StateHasChanged();
        });
    }

    private void UpdateSeriesData(ChartSeries series, double newValue)
    {
        var dataList = series.Data.ToList();
        dataList.Add(newValue);
        series.Data = dataList.ToArray();
    }

    private void TrimSeriesData(ChartSeries series)
    {
        var dataList = series.Data.ToList();
        if (dataList.Count > 0)
        {
            dataList.RemoveAt(0);
            series.Data = dataList.ToArray();
        }
    }

    public class TrainingMetrics
    {
        public int Epoch { get; set; }
        public double? Loss { get; set; }
        public double? Accuracy { get; set; }
        public double? ValLoss { get; set; }
        public double? ValAccuracy { get; set; }
        public bool IsTrainingComplete { get; set; } // New property
    }
}
